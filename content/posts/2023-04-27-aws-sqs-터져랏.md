---
title: "AWS-SQS-터져랏"
date: 2023-04-27T21:45:04+09:00
draft: false
categories: ["AWS"]
tags: ["SQS", "python", "터저라시냅스"]
slug: "aws-sqs-터져랏"
aliases:
  - /aws-sqs-터져랏/
  - /aws-sqs-%ed%84%b0%ec%a0%b8%eb%9e%8f/
---

\n

일단 SQS를 터질때 까지 밀어넣어 보기로 했다.

\n\n\n\n

목표 메시지수는 100만건.

\n\n\n\n

100만건의 메시지를 100초안에 SQS에 넣는게 목표다. TPS 10000 이라는 소리다.

\n\n\n\n

목표를 이루기위해선 첫번째 SQS의 TPS는 3000이다. 초당 3000의 메시지를 넣을수 있다.

\n\n\n\n

먼저 큐를 4개를 만들었다. 목표수치에 가려면 TPS가 10000은 나와야한다.

\n\n\n\n

그렇다면 큐를 병렬로 줄세운다 4개의 큐를 만든다.

\n\n\n\n
![](/images/2023/04/image-3.png)
\n\n\n\n

이제 넣어봤다.

\n\n\n\n

```
import boto3\nimport json\nimport uuid\nfrom concurrent.futures import ThreadPoolExecutor\nimport random\nimport string\n\nsqs = boto3.client('sqs')\nqueue_urls = [\n    'linuxer-sqs-1',\n    'linuxer-sqs-2',\n    'linuxer-sqs-3',\n    'linuxer-sqs-4'\n]\n\ndef random_string(length):\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\ndef create_dummy_data():\n    return {\n        'id': str(uuid.uuid4()),\n        'data': f"host-{random_string(5)}-count",\n        'padding': random_string(10 * 1024 - 100)  # 10KB 크기의 더미 데이터를 생성\n    }\n\ndef send_message_batch(queue_url, messages):\n    entries = []\n\n    for idx, message in enumerate(messages):\n        entries.append({\n            'Id': str(idx),\n            'MessageBody': json.dumps(message)\n        })\n\n    response = sqs.send_message_batch(\n        QueueUrl=queue_url,\n        Entries=entries\n    )\n    return response\n\ndef generate_and_send_dummy_data(num_messages=100000, batch_size=10, num_threads=10):\n    with ThreadPoolExecutor(max_workers=num_threads) as executor:\n        for _ in range(num_messages // (batch_size * num_threads * len(queue_urls))):\n            batch_futures = []\n            for queue_url in queue_urls:\n                messages = [create_dummy_data() for _ in range(batch_size)]\n                future = executor.submit(send_message_batch, queue_url, messages)\n                batch_futures.append(future)\n\n            for future in batch_futures:\n                future.result()\n\nif __name__ == '__main__':\n    generate_and_send_dummy_data()\n
```

\n\n\n\n

대충 이코드는 TPS 100 정도이다.

\n\n\n\n
![](/images/2023/04/image-5.png)
\n\n\n\n

5분 정도 걸려서 10만 건의 메시지를 모두 PUT했다. 분당 20000 TPS 333정도다.

\n\n\n\n

병렬처리했다.

\n\n\n\n

```
import boto3\nimport json\nimport uuid\nfrom concurrent.futures import ThreadPoolExecutor\nfrom multiprocessing import Process\nimport random\nimport string\n\nsqs = boto3.client('sqs')\nqueue_urls = [\n    'linuxer-sqs-1',\n    'linuxer-sqs-2',\n    'linuxer-sqs-3',\n    'linuxer-sqs-4'\n]\n\ndef random_string(length):\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\ndef create_dummy_data():\n    return {\n        'id': str(uuid.uuid4()),\n        'data': f"host-{random_string(5)}-count",\n        'padding': random_string(10 * 1024 - 100)  # 10KB 크기의 더미 데이터를 생성\n    }\n\ndef send_message_batch(queue_url, messages):\n    entries = []\n\n    for idx, message in enumerate(messages):\n        entries.append({\n            'Id': str(idx),\n            'MessageBody': json.dumps(message)\n        })\n\n    response = sqs.send_message_batch(\n        QueueUrl=queue_url,\n        Entries=entries\n    )\n    return response\n\ndef generate_and_send_dummy_data(queue_url, num_messages=1000000, batch_size=10, num_threads=10):\n    with ThreadPoolExecutor(max_workers=num_threads) as executor:\n        for _ in range(num_messages // (batch_size * num_threads)):\n            batch_futures = []\n            for _ in range(num_threads):\n                messages = [create_dummy_data() for _ in range(batch_size)]\n                future = executor.submit(send_message_batch, queue_url, messages)\n                batch_futures.append(future)\n\n            for future in batch_futures:\n                future.result()\n\ndef start_processes(num_processes):\n    processes = []\n    for queue_url in queue_urls:\n        for _ in range(num_processes):\n            process = Process(target=generate_and_send_dummy_data, args=(queue_url,))\n            processes.append(process)\n            process.start()\n\n    for process in processes:\n        process.join()\n\nif __name__ == '__main__':\n    num_processes = 4\n    start_processes(num_processes)\n
```

\n\n\n\n

```
501 17512 16975   0  9:27PM ttys001    0:00.21 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python main.py\n  501 17513 17512   0  9:27PM ttys001    0:00.05 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.resource_tracker import main;main(6)\n  501 17514 17512   0  9:27PM ttys001    0:14.41 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=9) --multiprocessing-fork\n  501 17515 17512   0  9:27PM ttys001    0:14.50 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=11) --multiprocessing-fork\n  501 17516 17512   0  9:27PM ttys001    0:14.36 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=14) --multiprocessing-fork\n  501 17517 17512   0  9:27PM ttys001    0:14.60 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=16) --multiprocessing-fork\n  501 17518 17512   0  9:27PM ttys001    0:14.55 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=18) --multiprocessing-fork\n  501 17519 17512   0  9:27PM ttys001    0:14.21 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=20) --multiprocessing-fork\n  501 17520 17512   0  9:27PM ttys001    0:14.16 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=22) --multiprocessing-fork\n  501 17521 17512   0  9:27PM ttys001    0:14.11 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=24) --multiprocessing-fork\n  501 17522 17512   0  9:27PM ttys001    0:14.46 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=27) --multiprocessing-fork\n  501 17523 17512   0  9:27PM ttys001    0:14.55 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=29) --multiprocessing-fork\n  501 17524 17512   0  9:27PM ttys001    0:14.24 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=31) --multiprocessing-fork\n  501 17525 17512   0  9:27PM ttys001    0:14.19 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=33) --multiprocessing-fork\n  501 17526 17512   0  9:27PM ttys001    0:14.28 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=35) --multiprocessing-fork\n  501 17527 17512   0  9:27PM ttys001    0:14.18 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=37) --multiprocessing-fork\n  501 17528 17512   0  9:27PM ttys001    0:14.49 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=39) --multiprocessing-fork\n  501 17529 17512   0  9:27PM ttys001    0:14.46 /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=7, pipe_handle=41) --multiprocessing-fork
```

\n\n\n\n

이제 멀티프로세스로 꼽는다!!

\n\n\n\n
![](/images/2023/04/image-6.png)
\n\n\n\n

코드보니 400만개를 넣도록 되어있어서 100만개 넣을시점에 끊었다.

\n\n\n\n
![](/images/2023/04/image-7.png)
\n\n\n\n

10분정도에 100만개의 메시지.. TPS 1600 정도다 아직 더 올릴수 있는 가망성이 보이지만 이건이제 컴퓨팅의 문제다.  
이제 병렬처리만으로도 가능함을 알았으니..producer 의 병렬성을 더 올린다. **num\_processes = 12** 4배다! 일단 터트려 보자.

\n\n\n\n

```
ps -ef | grep "multiprocessing.spawn" | wc -l\n      49\n
```

\n\n\n\n

49개의 프로세스가 미친듯이 공격을 한다. M1 진짜 좋다.

\n\n\n\n

아...내 노트북으로 낼수있는 TPS는 1600이 한계다. 이제 컨슈밍을 할거다. SQS에 있는 데이터를 꺼내쓰는 속도를 확인할거다. 큐에는 100만개의 데이터가 쌓여있고 이걸 모두 소모하는 속도를 확인하려한다.

\n\n\n\n

```
import boto3\nimport time\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nfrom multiprocessing import Process\n\nsqs = boto3.client('sqs')\nqueue_urls = [\n    'linuxer-sqs-1',\n    'linuxer-sqs-2',\n    'linuxer-sqs-3',\n    'linuxer-sqs-4'\n]\n\ndef receive_and_delete_message(queue_url, wait_time=20):\n    while True:\n        response = sqs.receive_message(\n            QueueUrl=queue_url,\n            AttributeNames=['All'],\n            MaxNumberOfMessages=1,\n            WaitTimeSeconds=wait_time\n        )\n\n        if 'Messages' in response:\n            message = response['Messages'][0]\n            receipt_handle = message['ReceiptHandle']\n            sqs.delete_message(\n                QueueUrl=queue_url,\n                ReceiptHandle=receipt_handle\n            )\n        else:\n            break\n\ndef process_messages(queue_url, num_threads=10):\n    with ThreadPoolExecutor(max_workers=num_threads) as executor:\n        futures = [executor.submit(receive_and_delete_message, queue_url) for _ in range(num_threads)]\n        for future in as_completed(futures):\n            future.result()\n\ndef start_processes(num_processes):\n    processes = []\n    for queue_url in queue_urls:\n        for _ in range(num_processes):\n            process = Process(target=process_messages, args=(queue_url,))\n            processes.append(process)\n            process.start()\n\n    for process in processes:\n        process.join()\n\nif __name__ == '__main__':\n    num_processes = 100\n    start_time = time.time()\n    start_processes(num_processes)\n    end_time = time.time()\n\n    print(f"Elapsed time: {end_time - start_time:.2f} seconds")\n
```

\n\n\n\n

멀티프로세스 100개를 돌렸더니 M1이 뻣었다. 그렇지만 1분에 10만개 정도는 가볍게 뽑아가는걸 확인할수있었다.

\n\n\n\n
![](/images/2023/04/image-8.png)
\n\n\n\n

이 결과만으로 SQS는 튼튼한 큐라는걸 알수 있었다. 그럼 이렇게 하드코어하게 넣었으니 에러레이트를 확인해 봐야했다.

\n\n\n\n
![](/images/2023/04/image-9-1024x870.png)
\n\n\n\n

지연되거나 데드레터큐에 쌓인메시지는 없었다. 모두 정상적으로 소진된것이다.

\n\n\n\n

여기서 결론은 mac book M1 air 로서 낼수 있는 퍼포먼스는 TPS1600이다. 분당 10만건의 메시지를 처리할수 있는 능력이라는것.. 이다음은 컴퓨팅 자원을 마음껏 넣어서 큐를 터트려 보겠다.

\n\n\n\n

밤새 머리속에서 어떻게 하면 좋을까 고민하다가 EKS에서 Job을 이용해 병렬 처리속도를 늘려보기로 했다.

\n\n\n\n

도커로 말고~

\n\n\n\n

CMD로 job을 실행할때 파일을 지정해서 실행하도록 했다.

\n\n\n\n

```
# Dockerfile\nFROM python:3.8-slim\n\nWORKDIR /app\n\nCOPY requirements.txt ./\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY send.py receive.py ./\n\nCMD ["python", "receive.py"]
```

\n\n\n\n

```
apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: sqs-test\nspec:\n  parallelism: 20\n  template:\n    spec:\n      containers:\n      - name: sqs-test\n        image: sqs_test:latest\n        command: ["python3", "send.py"] // ["python", "receive.py"] 로 변경할수 있다.\n        resources:\n          limits:\n            cpu: "2"\n            memory: "2Gi"\n          requests:\n            cpu: "1500m"\n            memory: "1Gi"\n      restartPolicy: Never\n  backoffLimit: 4
```

\n\n\n\n

컨테이너 말고 parallelism 으로 20의 pod를 예약했다.

\n\n\n\n
![](/images/2023/04/image-10.png)
\n\n\n\n

Send 는 분당 26만개 TPS 대략 4300

\n\n\n\n
![](/images/2023/04/image-11.png)
\n\n\n\n

receive 는 32만개 대략 TPS 5000 정도이다.

\n\n\n\n

5분에 100만개를 처리할수 있는 능력이라 보이고 이 플로우의 장점은 job에서 모든 데이터를 다꺼내쓰면 Completed로 컨테이너가 완료되므로 시간에 따른 큐에 대한 스케줄링이 가능하다는 뜻이다.

\n\n\n\n

job을 스케줄링할때 큐에 쌓인 지연시간+큐에쌓인 갯수를 모니터링하고 job을 이용해 큐를 비우는 방식의 아키텍처를 설계할수 있다는 이야기다.

\n\n\n\n

```
 k get pod\nNAME                  READY   STATUS      RESTARTS   AGE\nsqs-test-send-2s6h4   0/1     Completed   0          4m23s\nsqs-test-send-5276z   0/1     Completed   0          4m23s\nsqs-test-send-72ndr   0/1     Completed   0          4m22s\nsqs-test-send-c24kn   0/1     Completed   0          4m22s\nsqs-test-send-ccz5r   0/1     Completed   0          4m23s\nsqs-test-send-fjfnk   0/1     Completed   0          4m23s\nsqs-test-send-h2jhv   0/1     Completed   0          4m22s\nsqs-test-send-k7b8q   0/1     Completed   0          4m22s\nsqs-test-send-ljbv5   0/1     Completed   0          4m23s\nsqs-test-send-mjvh9   0/1     Completed   0          4m23s\nsqs-test-send-n8wh4   0/1     Completed   0          4m23s\nsqs-test-send-ngskk   0/1     Completed   0          4m22s\nsqs-test-send-qj9ks   0/1     Completed   0          4m22s\nsqs-test-send-r87hf   0/1     Completed   0          4m22s\nsqs-test-send-rr58h   0/1     Completed   0          4m23s\nsqs-test-send-sf2bd   0/1     Completed   0          4m23s\nsqs-test-send-svn8d   0/1     Completed   0          4m22s\nsqs-test-send-tqfg4   0/1     Completed   0          4m23s\nsqs-test-send-tv68j   0/1     Completed   0          4m22s\nsqs-test-send-w99hx   0/1     Completed   0          4m23s
```

\n\n\n\n

결과가 놀라운데 4분23초 만에 pod의 스케줄링+job(120만건의 메시징컨슘)이 모두 완료된건이다.

\n\n\n\n

이아키텍처에는 카펜터가 사용되었는데, 카펜터의 노드는 0에서 시작하여 새로 노드를 프로비저닝해서 깔끔하게 모두 완료된것이다. 스케줄링이 놀랍다.

\n\n\n\n

재미있는 테스트였다.

\n\n\n\n

이다음은 KaFka를 테스트 하겠다.

\n